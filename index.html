<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bluer Exif Frame</title>
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Bluer Frame">
    <meta name="theme-color" content="#ffffff">

    <link rel="apple-touch-icon" href="./icon.png">
    <link rel="icon" type="image/png" href="./icon.png">

    <!-- Tailwind & Libs -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        body {
            overscroll-behavior-y: none;
            -webkit-tap-highlight-color: transparent;
            font-family: -apple-system, BlinkMacSystemFont, "Montserrat", "Segoe UI", Roboto, sans-serif;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            background-color: #f9fafb;
            user-select: none;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;700&display=swap');
    </style>
</head>
<body>
    <div id="root" class="flex-1 flex flex-col h-full overflow-hidden"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // --- DATABASE CROP FACTOR ---
        const CAMERA_DB = {
            'rx100': 2.7, 'zv-1': 2.7, 'rx10': 2.7, 'rx1': 1.0,
            'g7 x': 2.7, 'g5 x': 2.7, 'g9 x': 2.7, 's100': 4.6, 's110': 4.6, 's120': 4.6, 'ixus': 5.6,
            'gr ii': 1.5, 'gr iii': 1.5, 'gr digital': 4.6, 'cx': 5.6, 'caplio': 5.6,
            'x100': 1.5, 'x-': 1.5, 'gfx': 0.79, 'x10': 3.9, 'x20': 3.9, 'x30': 3.9,
            'lx100': 2.2, 'lx10': 2.7, 'lx15': 2.7, 'tz': 5.6, 'zs': 5.6,
            'tg-': 5.6, 'xz-': 4.7,
            'coolpix a': 1.5, 'p900': 5.6, 'p1000': 5.6, '1 j': 2.7, '1 v': 2.7,
        };

        // --- Icons ---
        const Icon = ({ path, className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d={path} /></svg>
        );
        const Icons = {
            Camera: (p) => <Icon {...p} path="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z M12 13a3 3 0 1 0 0-6 3 3 0 0 0 0 6z" />,
            Upload: (p) => <Icon {...p} path="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4 M17 8l-5-5-5 5 M12 3v12" />,
            ImageIcon: (p) => <Icon {...p} path="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2z M8.5 10a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z M21 15l-5-5L5 21" />,
            Settings: (p) => <Icon {...p} path="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z" />,
            Trash2: (p) => <Icon {...p} path="M3 6h18 M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2 M10 11v6 M14 11v6" />,
            X: (p) => <Icon {...p} path="M18 6L6 18 M6 6l12 12" />,
            Check: (p) => <Icon {...p} path="M20 6L9 17l-5-5" />,
            Share: (p) => <Icon {...p} path="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8 M16 6l-4-4-4 4 M12 2v13" />,
            AlertCircle: (p) => <Icon {...p} path="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />,
            FolderDown: (p) => <Icon {...p} path="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2v11z M12 11v6 M9 14l3 3 3-3" />,
            Loader2: (p) => <svg className={`${p.className} animate-spin`} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56" /></svg>,
            Info: (p) => <Icon {...p} path="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />
        };

        // --- Helpers ---
        const formatExposureTime = (time) => {
            if (!time) return '';
            if (time >= 1) return time.toString();
            const common = [2, 4, 8, 15, 30, 60, 125, 250, 500, 1000, 2000, 4000, 8000];
            let best = `1/${Math.round(1/time)}`;
            let minErr = Math.abs(time - 1/Math.round(1/time));
            for (const den of common) {
                const err = Math.abs(time - 1/den);
                if (err < minErr && err < 0.0001) { minErr = err; best = `1/${den}s`; }
            }
            return best.endsWith('s') ? best : `1/${Math.round(1/time)}s`;
        };

        // UPDATED: Logic làm tròn số F-Number
        const formatFNumber = (f) => {
            if (!f) return '';
            // Làm tròn 1 chữ số thập phân (1.779 -> 1.8)
            const val = Math.round(f * 10) / 10;
            return `f/${val}`;
        };

        const formatISO = (iso) => iso ? `ISO ${iso}` : '';
        const cleanModelName = (make, model) => {
            const m = String(make || '').replace(/\0/g, '').trim();
            let mo = String(model || '').replace(/\0/g, '').trim();
            if (mo.toLowerCase().startsWith(m.toLowerCase())) mo = mo.substring(m.length).trim();
            return `${m} ${mo}`.trim();
        };
        const formatFocalLength = (fl, fl35, make, model) => {
            if (fl35 && fl35 > 0) return `${Math.round(fl35)}mm`;
            if (fl) {
                const mStr = (String(make || '') + ' ' + String(model || '')).toLowerCase();
                for (const [key, factor] of Object.entries(CAMERA_DB)) {
                    if (mStr.includes(key)) return `${Math.round(fl * factor)}mm`;
                }
                if (mStr.includes('fujifilm') || mStr.includes('nikon') || mStr.includes('sony')) return `${Math.round(fl * 1.5)}mm`;
                if (mStr.includes('olympus') || mStr.includes('panasonic')) return `${Math.round(fl * 2.0)}mm`;
                if (mStr.includes('canon')) return `${Math.round(fl * 1.6)}mm`;
                return `${Math.round(fl)}mm`;
            }
            return '';
        };

        // --- MAIN APP ---
        function App() {
            const [images, setImages] = useState([]);
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [activeTab, setActiveTab] = useState('layout');
            const [libsLoaded, setLibsLoaded] = useState(false);
            
            const [settings, setSettings] = useState({
                borderWidthPercent: 15,
                bottomPaddingPercent: 20,
                backgroundColor: '#ffffff',
                textColor: '#222222',
                showCameraModel: true,
                showSettings: true,
                showDate: false,
                fontFamily: 'Montserrat, sans-serif',
                watermarkText: '',
            });

            useEffect(() => {
                const checkLibs = setInterval(() => {
                    if (window.EXIF) {
                        setLibsLoaded(true);
                        clearInterval(checkLibs);
                    }
                }, 100);
                return () => clearInterval(checkLibs);
            }, []);

            const handleFileUpload = (e) => {
                if (e.target.files && e.target.files.length > 0) {
                    const newImages = Array.from(e.target.files).map(file => ({
                        id: Math.random().toString(36).substr(2, 9),
                        file,
                        previewUrl: URL.createObjectURL(file),
                        finalUrl: null,
                        exif: null,
                        status: 'pending',
                    }));
                    setImages(prev => [...prev, ...newImages]);
                    setTimeout(() => processQueue(newImages), 100);
                    setIsSettingsOpen(false);
                    e.target.value = '';
                }
            };

            const processQueue = async (queue) => {
                for (const imgItem of queue) { await processSingleImage(imgItem); }
            };

            const processSingleImage = async (imgItem) => {
                setImages(prev => prev.map(img => img.id === imgItem.id ? { ...img, status: 'processing' } : img));
                
                let extractedExif = null;
                try {
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = e => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(imgItem.file);
                    });

                    if (window.EXIF) {
                        const tags = window.EXIF.readFromBinaryFile(arrayBuffer);
                        if (tags && (tags.Make || tags.Model || tags.FocalLength)) {
                            extractedExif = {
                                Make: tags.Make, Model: tags.Model, FNumber: tags.FNumber,
                                ExposureTime: tags.ExposureTime, ISOSpeedRatings: tags.ISOSpeedRatings,
                                FocalLength: tags.FocalLength, FocalLengthIn35mmFilm: tags.FocalLengthIn35mmFilm,
                                DateTimeOriginal: tags.DateTimeOriginal,
                            };
                        }
                    }
                } catch (err) { console.error("EXIF error", err); }

                return new Promise((resolve) => {
                    const originalImg = new Image();
                    originalImg.crossOrigin = "Anonymous";
                    originalImg.src = imgItem.previewUrl;
                    
                    originalImg.onload = () => {
                        const finalCanvas = document.createElement('canvas');
                        const finalCtx = finalCanvas.getContext('2d');
                        if (finalCtx) {
                            drawFrameOnCanvas(finalCanvas, finalCtx, originalImg, extractedExif || {}, settings);
                            const finalUrl = finalCanvas.toDataURL('image/jpeg', 1.0);
                            setImages(prev => prev.map(p => p.id === imgItem.id ? { ...p, finalUrl, exif: extractedExif, status: 'done' } : p));
                        }
                        resolve();
                    };
                    originalImg.onerror = () => {
                        setImages(prev => prev.map(p => p.id === imgItem.id ? { ...p, status: 'error' } : p));
                        resolve();
                    }
                });
            };

            const reProcessAll = () => { if(images.length > 0) processQueue(images); };

            const drawFrameOnCanvas = (canvas, ctx, sourceImg, exif, cfg) => {
                const sourceW = sourceImg.naturalWidth || sourceImg.width;
                const sourceH = sourceImg.naturalHeight || sourceImg.height;
                if (!sourceW || !sourceH) return;

                const shortSide = Math.min(sourceW, sourceH);
                const baseP = Math.floor(shortSide * (cfg.borderWidthPercent / 100));
                
                const isLandscape = sourceW > sourceH;
                const targetRatio = isLandscape ? 5/4 : 4/5; 
                let wOut = sourceW + (baseP * 2);
                let hOut = wOut / targetRatio;
                let calcBottom = hOut - sourceH - baseP;
                const minBottomRequired = Math.floor(shortSide * (cfg.bottomPaddingPercent / 100));

                let canvasW, canvasH, topP, bottomP, sideP;

                if (calcBottom >= minBottomRequired) {
                    canvasW = wOut;
                    canvasH = hOut;
                    topP = baseP;
                    sideP = baseP;
                    bottomP = calcBottom; 
                } else {
                    let hOutFixed = sourceH + baseP + minBottomRequired;
                    let wOutFixed = hOutFixed * targetRatio;
                    canvasH = hOutFixed;
                    canvasW = wOutFixed;
                    topP = baseP;
                    bottomP = minBottomRequired;
                    sideP = (canvasW - sourceW) / 2;
                }
                
                canvas.width = canvasW;
                canvas.height = canvasH;

                ctx.fillStyle = cfg.backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(sourceImg, Math.floor(sideP), Math.floor(topP), sourceW, sourceH);

                ctx.fillStyle = cfg.textColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const baseFontSize = shortSide * 0.035; 
                
                const bottomAreaCenterY = topP + sourceH + (bottomP / 2);
                const centerX = canvas.width / 2;

                let mainText = "";
                let subText = "";
                if (cfg.showCameraModel) mainText = cleanModelName(exif.Make, exif.Model);
                if (cfg.watermarkText) mainText = mainText ? `${mainText} | ${cfg.watermarkText}` : cfg.watermarkText;

                if (cfg.showSettings) {
                    const parts = [];
                    const flString = formatFocalLength(exif.FocalLength, exif.FocalLengthIn35mmFilm, exif.Make, exif.Model);
                    if (flString) parts.push(flString);
                    if (exif.FNumber) parts.push(formatFNumber(exif.FNumber));
                    if (exif.ExposureTime) parts.push(formatExposureTime(exif.ExposureTime));
                    if (exif.ISOSpeedRatings) parts.push(formatISO(exif.ISOSpeedRatings));
                    subText = parts.join('  •  ');
                }
                if (cfg.showDate && exif.DateTimeOriginal) {
                    const datePart = String(exif.DateTimeOriginal || '').split(' ')[0].replace(/:/g, '/');
                    if (datePart.length > 5) subText = subText ? `${subText}   |   ${datePart}` : datePart;
                }
                
                ctx.font = `700 ${baseFontSize}px ${cfg.fontFamily}`;
                if (subText) {
                    ctx.fillText(mainText, centerX, bottomAreaCenterY - (baseFontSize * 0.6));
                    ctx.font = `500 ${baseFontSize * 0.7}px ${cfg.fontFamily}`;
                    ctx.globalAlpha = 0.85;
                    ctx.fillText(subText, centerX, bottomAreaCenterY + (baseFontSize * 0.6));
                } else {
                    ctx.fillText(mainText, centerX, bottomAreaCenterY);
                }
            };

            const handleShareOrSaveSingle = async (img) => {
                if (!img.finalUrl) return;
                const fileName = `${img.file.name.replace(/\.[^/.]+$/, "")}_framed.jpg`;
                if (navigator.share && navigator.canShare) {
                    try {
                        const response = await fetch(img.finalUrl);
                        const blob = await response.blob();
                        const file = new File([blob], fileName, { type: 'image/jpeg' });
                        if (navigator.canShare({ files: [file] })) {
                            await navigator.share({ files: [file] });
                            return;
                        }
                    } catch (e) { console.error(e); }
                }
                const link = document.createElement('a');
                link.href = img.finalUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const handleSaveAll = async () => {
                const doneImages = images.filter(i => i.status === 'done' && i.finalUrl);
                if (doneImages.length === 0) return;
                if (navigator.share && navigator.canShare) {
                    try {
                        const files = await Promise.all(doneImages.map(async (img) => {
                            const res = await fetch(img.finalUrl);
                            const blob = await res.blob();
                            return new File([blob], `${img.file.name.replace(/\.[^/.]+$/, "")}_framed.jpg`, { type: 'image/jpeg' });
                        }));
                        if (navigator.canShare({ files })) {
                            await navigator.share({ files, title: 'Ảnh đã đóng khung' });
                            return;
                        }
                    } catch (e) { console.log('Share fallback'); }
                }
                if (window.JSZip) {
                    const zip = new window.JSZip();
                    doneImages.forEach(img => {
                        const base64Data = img.finalUrl.split(',')[1];
                        zip.file(`${img.file.name.replace(/\.[^/.]+$/, "")}_framed.jpg`, base64Data, {base64: true});
                    });
                    const content = await zip.generateAsync({ type: "blob" });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(content);
                    link.download = "bluer_exif_frames.zip";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            };

            return (
                <div className="flex flex-col h-full">
                    <header className="bg-white border-b border-gray-200 px-4 py-3 flex items-center justify-between shadow-sm z-30 shrink-0">
                        <div className="flex items-center gap-2">
                            <Icons.Camera className="w-6 h-6 text-blue-600" />
                            <h1 className="text-lg font-bold">Bluer Exif Frame</h1>
                        </div>
                        <label className={`bg-blue-600 text-white p-2 rounded-full flex items-center justify-center shadow-sm transition-all ${libsLoaded ? 'cursor-pointer active:bg-blue-700' : 'opacity-50 cursor-not-allowed'}`}>
                            {libsLoaded ? <Icons.Upload className="w-5 h-5" /> : <Icons.Loader2 className="w-5 h-5" />}
                            <input type="file" multiple accept="image/jpeg,image/png,image/webp" className="hidden" onChange={handleFileUpload} disabled={!libsLoaded} />
                        </label>
                    </header>

                    <main className="flex-1 overflow-y-auto p-4 pb-32">
                        {images.length === 0 ? (
                            <div className="flex flex-col items-center justify-center h-[60vh] text-gray-400 border-2 border-dashed border-gray-300 rounded-2xl bg-white/50" onClick={() => libsLoaded && document.querySelector('input[type=file]')?.click()}>
                                <Icons.ImageIcon className="w-12 h-12 mb-3 text-gray-300" />
                                <p className="font-medium">
                                    {libsLoaded ? "Chạm để thêm ảnh" : "Đang tải thư viện..."}
                                </p>
                            </div>
                        ) : (
                            <div className="flex flex-col gap-6">
                                <div className="bg-blue-50 p-3 rounded-lg border border-blue-100 flex items-start gap-2">
                                    <Icons.Info className="w-4 h-4 text-blue-600 mt-0.5 shrink-0" />
                                    <p className="text-xs text-blue-800 leading-snug">Mẹo: Chọn <b>Lưu hình ảnh</b> khi chia sẻ để lưu về Photos.</p>
                                </div>
                                {images.map((img) => (
                                    <div key={img.id} className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden relative">
                                        <div className="relative bg-gray-100 flex items-center justify-center min-h-[200px]">
                                            {img.status === 'processing' && <div className="absolute inset-0 bg-white/80 z-10 flex items-center justify-center"><Icons.Loader2 className="w-8 h-8 text-blue-600" /></div>}
                                            <img src={img.finalUrl || img.previewUrl} className={`w-full h-auto object-contain ${!img.finalUrl ? 'opacity-50' : ''}`} />
                                        </div>
                                        <div className="p-3">
                                            <div className="flex justify-between items-center mb-3">
                                                <div className="flex-1 overflow-hidden mr-2">
                                                    <p className="text-xs font-bold truncate text-gray-700">{img.file.name}</p>
                                                    {img.status === 'done' && !img.exif && <span className="inline-flex items-center gap-1 text-[10px] text-amber-600 bg-amber-50 px-2 py-0.5 rounded mt-1 border border-amber-100"><Icons.AlertCircle className="w-3 h-3" /> Không tìm thấy EXIF</span>}
                                                </div>
                                                <button onClick={() => setImages(prev => prev.filter(i => i.id !== img.id))} className="text-gray-400 p-2 -mr-2 active:text-red-500"><Icons.Trash2 className="w-5 h-5" /></button>
                                            </div>
                                            <button onClick={() => handleShareOrSaveSingle(img)} disabled={!img.finalUrl} className="w-full bg-white border border-gray-200 text-gray-900 hover:bg-gray-50 py-3 rounded-lg text-sm font-bold flex items-center justify-center gap-2 active:scale-95 transition-transform"><Icons.Share className="w-4 h-4" /> Lưu / Chia sẻ</button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </main>

                    <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 p-2 pb-safe z-40 flex justify-around items-center shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
                        <button onClick={() => setIsSettingsOpen(!isSettingsOpen)} className={`flex flex-col items-center gap-1 p-2 rounded-lg flex-1 active:bg-gray-50 ${isSettingsOpen ? 'text-blue-600' : 'text-gray-500'}`}><Icons.Settings className="w-6 h-6" /><span className="text-[10px] font-medium">Cấu hình</span></button>
                        {images.length > 0 && <button onClick={reProcessAll} className="flex flex-col items-center gap-1 p-2 text-gray-500 active:text-blue-600 flex-1 active:bg-gray-50"><Icons.Check className="w-5 h-5" /><span className="text-[10px] font-medium">Làm mới</span></button>}
                        {images.length > 1 && <button onClick={handleSaveAll} className="flex flex-col items-center gap-1 p-2 text-blue-600 active:scale-95 transition-transform flex-1 active:bg-blue-50 rounded-lg"><Icons.FolderDown className="w-6 h-6" /><span className="text-[10px] font-bold">Lưu tất cả</span></button>}
                    </div>

                    {isSettingsOpen && (
                        <div className="fixed inset-0 z-50 flex items-end sm:items-center sm:justify-center">
                            <div className="absolute inset-0 bg-black/50 backdrop-blur-sm transition-opacity" onClick={() => setIsSettingsOpen(false)}></div>
                            <div className="relative bg-white w-full sm:max-w-md rounded-t-2xl sm:rounded-2xl shadow-2xl flex flex-col max-h-[85vh] animate-in slide-in-from-bottom duration-300">
                                <div className="flex justify-between items-center p-4 border-b border-gray-100">
                                    <h3 className="font-bold text-lg">Tùy chỉnh khung</h3>
                                    <button onClick={() => setIsSettingsOpen(false)} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200"><Icons.X className="w-5 h-5" /></button>
                                </div>
                                <div className="flex p-2 gap-2 bg-gray-50 mx-4 mt-2 rounded-lg shrink-0">
                                    {['layout', 'color', 'content'].map(tab => (
                                        <button key={tab} onClick={() => setActiveTab(tab)} className={`flex-1 py-2 rounded-md text-xs font-bold uppercase tracking-wide transition-all ${activeTab === tab ? 'bg-white shadow-sm text-blue-600' : 'text-gray-400 hover:text-gray-600'}`}>{tab === 'layout' ? 'Bố cục' : tab === 'color' ? 'Màu sắc' : 'Nội dung'}</button>
                                    ))}
                                </div>
                                <div className="p-5 overflow-y-auto">
                                    {activeTab === 'layout' && (
                                        <div className="space-y-6">
                                            <div><div className="flex justify-between mb-2"><span className="text-sm font-medium">Độ dày viền</span><span className="text-xs bg-gray-100 px-2 py-1 rounded">{settings.borderWidthPercent}%</span></div><input type="range" min="0" max="30" value={settings.borderWidthPercent} onChange={(e) => setSettings({...settings, borderWidthPercent: Number(e.target.value)})} className="w-full h-8 bg-gray-200 rounded-lg appearance-none accent-blue-600 cursor-pointer" /></div>
                                            <div><div className="flex justify-between mb-2"><span className="text-sm font-medium">Khoảng dưới (Min)</span><span className="text-xs bg-gray-100 px-2 py-1 rounded">{settings.bottomPaddingPercent}%</span></div><input type="range" min="5" max="50" value={settings.bottomPaddingPercent} onChange={(e) => setSettings({...settings, bottomPaddingPercent: Number(e.target.value)})} className="w-full h-8 bg-gray-200 rounded-lg appearance-none accent-blue-600 cursor-pointer" /></div>
                                        </div>
                                    )}
                                    {activeTab === 'color' && (
                                        <div className="space-y-4">
                                            <div className="flex items-center justify-between p-3 border rounded-xl"><span className="text-sm font-medium">Màu nền</span><input type="color" value={settings.backgroundColor} onChange={(e) => setSettings({...settings, backgroundColor: e.target.value})} className="w-10 h-10 rounded-full border-2 border-gray-200 p-0" /></div>
                                            <div className="flex items-center justify-between p-3 border rounded-xl"><span className="text-sm font-medium">Màu chữ</span><input type="color" value={settings.textColor} onChange={(e) => setSettings({...settings, textColor: e.target.value})} className="w-10 h-10 rounded-full border-2 border-gray-200 p-0" /></div>
                                        </div>
                                    )}
                                    {activeTab === 'content' && (
                                        <div className="space-y-4">
                                            <div className="space-y-3">{['showCameraModel', 'showSettings', 'showDate'].map(key => (<label key={key} className="flex items-center justify-between p-3 border rounded-xl active:bg-gray-50"><span className="text-sm font-medium">{key === 'showCameraModel' ? 'Tên thiết bị' : key === 'showSettings' ? 'Thông số kỹ thuật' : 'Ngày chụp'}</span><input type="checkbox" checked={settings[key]} onChange={(e) => setSettings({...settings, [key]: e.target.checked})} className="w-5 h-5 accent-blue-600" /></label>))}</div>
                                            <input type="text" value={settings.watermarkText} placeholder="Chữ ký (VD: By Tuan)" onChange={(e) => setSettings({...settings, watermarkText: e.target.value})} className="w-full p-4 border rounded-xl text-sm" />
                                            <select value={settings.fontFamily} onChange={(e) => setSettings({...settings, fontFamily: e.target.value})} className="w-full p-4 border rounded-xl text-sm bg-white"><option value="Montserrat, sans-serif">Montserrat (Hiện đại)</option><option value="Times New Roman, serif">Times New Roman (Cổ điển)</option></select>
                                        </div>
                                    )}
                                </div>
                                <div className="p-4 border-t bg-gray-50 rounded-b-2xl shrink-0"><button onClick={() => { reProcessAll(); setIsSettingsOpen(false); }} className="w-full py-4 bg-blue-600 text-white rounded-xl font-bold shadow-lg active:scale-95 transition-transform text-base">Áp dụng</button></div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>